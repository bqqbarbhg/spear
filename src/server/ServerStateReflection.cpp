// Generated by misc/gen-server-reflection.py
#include "ServerStateReflection.h"
#include "ServerState.h"
#include "sf/Reflection.h"

namespace sv { ReflectionInfo &addTypeReflectionInfo(sf::Type *type, const sf::String &fieldName); }

namespace sf {
using namespace sv;

template<> void initType<Component>(Type *t)
{
	static PolymorphType polys[] = {
		sf_poly(Component, Model, ModelComponent),
		sf_poly(Component, PointLight, PointLightComponent),
		sf_poly(Component, ParticleSystem, ParticleSystemComponent),
		sf_poly(Component, Character, CharacterComponent),
		sf_poly(Component, CharacterModel, CharacterModelComponent),
		sf_poly(Component, BlobShadow, BlobShadowComponent),
		sf_poly(Component, Card, CardComponent),
		sf_poly(Component, CardAttach, CardAttachComponent),
		sf_poly(Component, CardMelee, CardMeleeComponent),
		sf_poly(Component, CardProjectile, CardProjectileComponent),
		sf_poly(Component, CastOnTurnStart, CastOnTurnStartComponent),
		sf_poly(Component, CastOnReceiveDamage, CastOnReceiveDamageComponent),
		sf_poly(Component, CastOnDealDamage, CastOnDealDamageComponent),
		sf_poly(Component, ResistDamage, ResistDamageComponent),
		sf_poly(Component, CardCast, CardCastComponent),
		sf_poly(Component, Spell, SpellComponent),
		sf_poly(Component, SpellDamage, SpellDamageComponent),
		sf_poly(Component, SpellStatus, SpellStatusComponent),
		sf_poly(Component, Status, StatusComponent),
		sf_poly(Component, CharacterTemplate, CharacterTemplateComponent),
		sf_poly(Component, TileArea, TileAreaComponent),
	};
	sf_struct_poly(t, Component, type, { }, polys);
}

template<> void initType<Event>(Type *t)
{
	static PolymorphType polys[] = {
		sf_poly(Event, AllocateId, AllocateIdEvent),
		sf_poly(Event, CardCooldownTick, CardCooldownTickEvent),
		sf_poly(Event, StatusAdd, StatusAddEvent),
		sf_poly(Event, StatusTick, StatusTickEvent),
		sf_poly(Event, StatusRemove, StatusRemoveEvent),
		sf_poly(Event, ResistDamage, ResistDamageEvent),
		sf_poly(Event, CastSpell, CastSpellEvent),
		sf_poly(Event, CastSpell, MeleeAttackEvent),
		sf_poly(Event, Damage, DamageEvent),
		sf_poly(Event, LoadPrefab, LoadPrefabEvent),
		sf_poly(Event, ReloadPrefab, ReloadPrefabEvent),
		sf_poly(Event, MakeUniquePrefab, MakeUniquePrefabEvent),
		sf_poly(Event, RemoveGarbageIds, RemoveGarbageIdsEvent),
		sf_poly(Event, RemoveGarbagePrefabs, RemoveGarbagePrefabsEvent),
		sf_poly(Event, AddProp, AddPropEvent),
		sf_poly(Event, RemoveProp, RemovePropEvent),
		sf_poly(Event, ReplaceLocalProp, ReplaceLocalPropEvent),
		sf_poly(Event, AddCharacter, AddCharacterEvent),
		sf_poly(Event, AddCard, AddCardEvent),
		sf_poly(Event, MoveProp, MovePropEvent),
		sf_poly(Event, GiveCard, GiveCardEvent),
		sf_poly(Event, SelectCard, SelectCardEvent),
		sf_poly(Event, AddCharacterToSpawn, AddCharacterToSpawn),
		sf_poly(Event, SelectCharacterToSpawn, SelectCharacterToSpawnEvent),
		sf_poly(Event, Move, MoveEvent),
	};
	sf_struct_poly(t, Event, type, { }, polys);
}

template<> void initType<Edit>(Type *t)
{
	static PolymorphType polys[] = {
		sf_poly(Edit, PreloadPrefab, PreloadPrefabEdit),
		sf_poly(Edit, ModifyPrefab, ModifyPrefabEdit),
		sf_poly(Edit, MakeUniquePrefab, MakeUniquePrefabEdit),
		sf_poly(Edit, AddProp, AddPropEdit),
		sf_poly(Edit, CloneProp, ClonePropEdit),
		sf_poly(Edit, MoveProp, MovePropEdit),
		sf_poly(Edit, RemoveProp, RemovePropEdit),
	};
	sf_struct_poly(t, Edit, type, { }, polys);
}

template<> void initType<ModelComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(ModelComponent, model),
		sf_field(ModelComponent, shadowModel),
		sf_field(ModelComponent, material),
		sf_field(ModelComponent, position),
		sf_field(ModelComponent, rotation),
		sf_field(ModelComponent, scale),
		sf_field(ModelComponent, stretch),
		sf_field(ModelComponent, tintColor),
		sf_field(ModelComponent, castShadows),
	};
	sf_struct_base(t, ModelComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "model");
		info.description = "Model .fbx asset";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "shadowModel");
		info.description = "Model .fbx used for shadow instead of 'model'";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "material");
		info.description = "Material used fo the asset";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "position");
		info.description = "Offset (in meters) of the model relative to the entity";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.description = "Rotation (XYZ in degrees) of the model relative to the entity";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.description = "Uniform scaling applied to the model";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "stretch");
		info.description = "Non-uniform scaling in entity's local X/Y/Z directions";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "tintColor");
		info.description = "Modifies the base color of the model's material";
		info.color = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "castShadows");
		info.description = "Does the model cast shadows?";
	}
}

template<> void initType<PointLightComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(PointLightComponent, color),
		sf_field(PointLightComponent, intensity),
		sf_field(PointLightComponent, radius),
		sf_field(PointLightComponent, position),
		sf_field(PointLightComponent, castShadows),
	};
	sf_struct_base(t, PointLightComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "color");
		info.description = "Color of the light";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "intensity");
		info.description = "Brightness of the light";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "radius");
		info.description = "Maximum eistance in meters that the light can reach";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "position");
		info.description = "Offset (in meters) of the light in the entity";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "castShadows");
		info.description = "Does this light have shadows";
	}
}

template<> void initType<ParticleSystemComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(ParticleSystemComponent, texture),
		sf_field(ParticleSystemComponent, frameCount),
		sf_field(ParticleSystemComponent, timeStep),
		sf_field(ParticleSystemComponent, prewarmTime),
		sf_field(ParticleSystemComponent, updateRadius),
		sf_field(ParticleSystemComponent, cullPadding),
		sf_field(ParticleSystemComponent, updateOutOfCamera),
		sf_field(ParticleSystemComponent, renderOrder),
		sf_field(ParticleSystemComponent, spawnTime),
		sf_field(ParticleSystemComponent, spawnTimeVariance),
		sf_field(ParticleSystemComponent, burstAmount),
		sf_field(ParticleSystemComponent, burstAmountVariance),
		sf_field(ParticleSystemComponent, emitterOnTime),
		sf_field(ParticleSystemComponent, emitPosition),
		sf_field(ParticleSystemComponent, emitVelocity),
		sf_field(ParticleSystemComponent, emitVelocityAttractorOffset),
		sf_field(ParticleSystemComponent, emitVelocityAttractorStrength),
		sf_field(ParticleSystemComponent, drag),
		sf_field(ParticleSystemComponent, gravity),
		sf_field(ParticleSystemComponent, size),
		sf_field(ParticleSystemComponent, sizeVariance),
		sf_field(ParticleSystemComponent, lifeTime),
		sf_field(ParticleSystemComponent, lifeTimeVariance),
		sf_field(ParticleSystemComponent, scaleSpline),
		sf_field(ParticleSystemComponent, alphaSpline),
		sf_field(ParticleSystemComponent, additiveSpline),
		sf_field(ParticleSystemComponent, gradient),
		sf_field(ParticleSystemComponent, frameRate),
		sf_field(ParticleSystemComponent, relativeFrameRate),
		sf_field(ParticleSystemComponent, randomStartFrame),
		sf_field(ParticleSystemComponent, rotation),
		sf_field(ParticleSystemComponent, rotationVariance),
		sf_field(ParticleSystemComponent, spin),
		sf_field(ParticleSystemComponent, spinVariance),
	};
	sf_struct_base(t, ParticleSystemComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "texture");
		info.description = "Texture used for the effect";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "frameCount");
		info.description = "Number of frames in a sprite sheet";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "timeStep");
		info.description = "How large simulation steps to do, smaller values are heavier but more accurate";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prewarmTime");
		info.description = "Time to simulate after spawning the effect";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "updateRadius");
		info.description = "Size of the \"active area\" of this particle effect";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cullPadding");
		info.description = "How much to \"pad\" the area for culling, increase if the effect disappears";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "updateOutOfCamera");
		info.description = "Update even if not visible in the camera";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "renderOrder");
		info.description = "Smaller render order values are rendered first";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spawnTime");
		info.description = "Time in seconds between spawning particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spawnTimeVariance");
		info.description = "Random extra time between spawns";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "burstAmount");
		info.description = "How many particles to spawn in the beginning";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "burstAmountVariance");
		info.description = "Additional random particle amount to spawn in the beginning";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitterOnTime");
		info.description = "How long to emit particles (negative for infinite, zero for no emit)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitPosition");
		info.description = "Random position for new particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitVelocity");
		info.description = "Random velocity for new particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitVelocityAttractorOffset");
		info.description = "Position to apply extra velocity towards/away from";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitVelocityAttractorStrength");
		info.description = "Extra velocity towards (< 0) or away (> 1) from attractor offset";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "drag");
		info.description = "Air resistance slowing particles from moving";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "gravity");
		info.description = "Linear force applied to all particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "size");
		info.description = "Base size of particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "sizeVariance");
		info.description = "Random additional size for individual particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "lifeTime");
		info.description = "Time in seconds the particles live";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "lifeTimeVariance");
		info.description = "Random additional per-particle life time";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scaleSpline");
		info.description = "Particle scale over particle lifetime";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "alphaSpline");
		info.description = "Particle alpha over particle lifetime";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "additiveSpline");
		info.description = "Additive blending over particle lifetime";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "gradient");
		info.description = "Color gradient over particle lifetime";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "frameRate");
		info.description = "Texture animation speed in frames per second";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "relativeFrameRate");
		info.description = "Ties the tie frame rate to particle life time (for synchronization)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "randomStartFrame");
		info.description = "Start from a random frame in the sprite sheet";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.description = "Base rotation of the particles in degrees";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotationVariance");
		info.description = "Random per-particle extra rotation of the particles in degrees";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spin");
		info.description = "Rotation speed for the particles in degrees";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spinVariance");
		info.description = "Random per-particle speed for the particles in degrees";
	}
}

template<> void initType<CharacterComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CharacterComponent, name),
		sf_field(CharacterComponent, description),
		sf_field(CharacterComponent, image),
		sf_field(CharacterComponent, maxHealth),
		sf_field(CharacterComponent, baseArmor),
		sf_field(CharacterComponent, minWeightDice),
		sf_field(CharacterComponent, maxWeightDice),
		sf_field(CharacterComponent, skillSlots),
		sf_field(CharacterComponent, spellSlots),
		sf_field(CharacterComponent, itemSlots),
	};
	sf_struct_base(t, CharacterComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "description");
		info.multiline = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "image");
		info.asset = true;
	}
}

template<> void initType<CharacterModelComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CharacterModelComponent, modelName),
		sf_field(CharacterModelComponent, scale),
		sf_field(CharacterModelComponent, animations),
		sf_field(CharacterModelComponent, attachBones),
	};
	sf_struct_base(t, CharacterModelComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "modelName");
		info.asset = true;
	}
}

template<> void initType<BlobShadowComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(BlobShadowComponent, blobs),
	};
	sf_struct_base(t, BlobShadowComponent, Component, fields);
}

template<> void initType<CardComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardComponent, name),
		sf_field(CardComponent, description),
		sf_field(CardComponent, cooldown),
		sf_field(CardComponent, melee),
		sf_field(CardComponent, skill),
		sf_field(CardComponent, spell),
		sf_field(CardComponent, item),
	};
	sf_struct_base(t, CardComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "description");
		info.multiline = true;
	}
}

template<> void initType<CardAttachComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardAttachComponent, prefabName),
		sf_field(CardAttachComponent, boneName),
		sf_field(CardAttachComponent, scale),
		sf_field(CardAttachComponent, offset),
		sf_field(CardAttachComponent, animationTags),
	};
	sf_struct_base(t, CardAttachComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<CardMeleeComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardMeleeComponent, hitRoll),
	};
	sf_struct_base(t, CardMeleeComponent, Component, fields);
}

template<> void initType<CardProjectileComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardProjectileComponent, prefabName),
		sf_field(CardProjectileComponent, hitEffect),
		sf_field(CardProjectileComponent, flightSpeed),
	};
	sf_struct_base(t, CardProjectileComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<CastOnTurnStartComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CastOnTurnStartComponent, spellName),
	};
	sf_struct_base(t, CastOnTurnStartComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<CastOnReceiveDamageComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CastOnReceiveDamageComponent, onMelee),
		sf_field(CastOnReceiveDamageComponent, onSpell),
		sf_field(CastOnReceiveDamageComponent, spellName),
	};
	sf_struct_base(t, CastOnReceiveDamageComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<CastOnDealDamageComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CastOnDealDamageComponent, onMelee),
		sf_field(CastOnDealDamageComponent, onSpell),
		sf_field(CastOnDealDamageComponent, spellName),
	};
	sf_struct_base(t, CastOnDealDamageComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<ResistDamageComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(ResistDamageComponent, onSpell),
		sf_field(ResistDamageComponent, onMelee),
		sf_field(ResistDamageComponent, resistAmount),
		sf_field(ResistDamageComponent, successRoll),
		sf_field(ResistDamageComponent, effectName),
	};
	sf_struct_base(t, ResistDamageComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "effectName");
		info.prefab = true;
	}
}

template<> void initType<CardCastComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardCastComponent, spellName),
	};
	sf_struct_base(t, CardCastComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<SpellComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(SpellComponent, successRoll),
	};
	sf_struct_base(t, SpellComponent, Component, fields);
}

template<> void initType<SpellDamageComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(SpellDamageComponent, damageRoll),
	};
	sf_struct_base(t, SpellDamageComponent, Component, fields);
}

template<> void initType<SpellStatusComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(SpellStatusComponent, statusName),
	};
	sf_struct_base(t, SpellStatusComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "statusName");
		info.prefab = true;
	}
}

template<> void initType<StatusComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusComponent, turnsRoll),
		sf_field(StatusComponent, startEffect),
		sf_field(StatusComponent, activeEffect),
		sf_field(StatusComponent, endEffect),
	};
	sf_struct_base(t, StatusComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "startEffect");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "activeEffect");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "endEffect");
		info.prefab = true;
	}
}

template<> void initType<CharacterTemplateComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CharacterTemplateComponent, name),
		sf_field(CharacterTemplateComponent, description),
		sf_field(CharacterTemplateComponent, characterPrefab),
		sf_field(CharacterTemplateComponent, starterCards),
	};
	sf_struct_base(t, CharacterTemplateComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "description");
		info.multiline = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "characterPrefab");
		info.prefab = true;
	}
}

template<> void initType<TileAreaComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(TileAreaComponent, minCorner),
		sf_field(TileAreaComponent, maxCorner),
	};
	sf_struct_base(t, TileAreaComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minCorner");
		info.description = "Top-left corner of the tile area (in meters/tiles)";
		info.fixedBits = 16;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxCorner");
		info.description = "Bottom-right corner of the tile area (in meters/tiles)";
		info.fixedBits = 16;
	}
}

template<> void initType<AllocateIdEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AllocateIdEvent, id),
	};
	sf_struct_base(t, AllocateIdEvent, Component, fields);
}

template<> void initType<CardCooldownTickEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardCooldownTickEvent, cardId),
	};
	sf_struct_base(t, CardCooldownTickEvent, Component, fields);
}

template<> void initType<StatusAddEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusAddEvent, turnsRoll),
		sf_field(StatusAddEvent, status),
	};
	sf_struct_base(t, StatusAddEvent, Component, fields);
}

template<> void initType<StatusTickEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusTickEvent, statusId),
	};
	sf_struct_base(t, StatusTickEvent, Component, fields);
}

template<> void initType<StatusRemoveEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusRemoveEvent, statusId),
	};
	sf_struct_base(t, StatusRemoveEvent, Component, fields);
}

template<> void initType<ResistDamageEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(ResistDamageEvent, cardName),
		sf_field(ResistDamageEvent, effectName),
		sf_field(ResistDamageEvent, resistAmount),
		sf_field(ResistDamageEvent, resistDamage),
		sf_field(ResistDamageEvent, successRoll),
		sf_field(ResistDamageEvent, success),
	};
	sf_struct_base(t, ResistDamageEvent, Component, fields);
}

template<> void initType<CastSpellEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(CastSpellEvent, spellInfo),
		sf_field(CastSpellEvent, successRoll),
	};
	sf_struct_base(t, CastSpellEvent, Component, fields);
}

template<> void initType<MeleeAttackEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(MeleeAttackEvent, meleeInfo),
		sf_field(MeleeAttackEvent, hitRoll),
	};
	sf_struct_base(t, MeleeAttackEvent, Component, fields);
}

template<> void initType<DamageEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(DamageEvent, damageInfo),
		sf_field(DamageEvent, damageRoll),
		sf_field(DamageEvent, finalDamage),
		sf_field(DamageEvent, meleeArmor),
	};
	sf_struct_base(t, DamageEvent, Component, fields);
}

template<> void initType<LoadPrefabEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(LoadPrefabEvent, prefab),
	};
	sf_struct_base(t, LoadPrefabEvent, Component, fields);
}

template<> void initType<ReloadPrefabEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(ReloadPrefabEvent, prefab),
	};
	sf_struct_base(t, ReloadPrefabEvent, Component, fields);
}

template<> void initType<MakeUniquePrefabEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(MakeUniquePrefabEvent, clientId),
		sf_field(MakeUniquePrefabEvent, prefabName),
		sf_field(MakeUniquePrefabEvent, uniquePrefabName),
		sf_field(MakeUniquePrefabEvent, propIds),
	};
	sf_struct_base(t, MakeUniquePrefabEvent, Component, fields);
}

template<> void initType<RemoveGarbageIdsEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(RemoveGarbageIdsEvent, ids),
	};
	sf_struct_base(t, RemoveGarbageIdsEvent, Component, fields);
}

template<> void initType<RemoveGarbagePrefabsEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(RemoveGarbagePrefabsEvent, names),
	};
	sf_struct_base(t, RemoveGarbagePrefabsEvent, Component, fields);
}

template<> void initType<AddPropEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AddPropEvent, prop),
	};
	sf_struct_base(t, AddPropEvent, Component, fields);
}

template<> void initType<RemovePropEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(RemovePropEvent, propId),
	};
	sf_struct_base(t, RemovePropEvent, Component, fields);
}

template<> void initType<ReplaceLocalPropEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(ReplaceLocalPropEvent, clientId),
		sf_field(ReplaceLocalPropEvent, localId),
		sf_field(ReplaceLocalPropEvent, prop),
	};
	sf_struct_base(t, ReplaceLocalPropEvent, Component, fields);
}

template<> void initType<AddCharacterEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AddCharacterEvent, character),
	};
	sf_struct_base(t, AddCharacterEvent, Component, fields);
}

template<> void initType<AddCardEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AddCardEvent, card),
	};
	sf_struct_base(t, AddCardEvent, Component, fields);
}

template<> void initType<MovePropEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(MovePropEvent, propId),
		sf_field(MovePropEvent, transform),
	};
	sf_struct_base(t, MovePropEvent, Component, fields);
}

template<> void initType<GiveCardEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(GiveCardEvent, cardId),
		sf_field(GiveCardEvent, previousOwnerId),
		sf_field(GiveCardEvent, ownerId),
	};
	sf_struct_base(t, GiveCardEvent, Component, fields);
}

template<> void initType<SelectCardEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(SelectCardEvent, ownerId),
		sf_field(SelectCardEvent, cardId),
		sf_field(SelectCardEvent, slot),
	};
	sf_struct_base(t, SelectCardEvent, Component, fields);
}

template<> void initType<AddCharacterToSpawn>(Type *t)
{
	static Field fields[] = {
		sf_field(AddCharacterToSpawn, selectPrefab),
		sf_field(AddCharacterToSpawn, count),
	};
	sf_struct_base(t, AddCharacterToSpawn, Component, fields);
}

template<> void initType<SelectCharacterToSpawnEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(SelectCharacterToSpawnEvent, selectPrefab),
		sf_field(SelectCharacterToSpawnEvent, playerId),
	};
	sf_struct_base(t, SelectCharacterToSpawnEvent, Component, fields);
}

template<> void initType<MoveEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(MoveEvent, characterId),
		sf_field(MoveEvent, position),
		sf_field(MoveEvent, waypoints),
	};
	sf_struct_base(t, MoveEvent, Component, fields);
}

template<> void initType<PreloadPrefabEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(PreloadPrefabEdit, prefabName),
	};
	sf_struct_base(t, PreloadPrefabEdit, Component, fields);
}

template<> void initType<ModifyPrefabEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(ModifyPrefabEdit, prefab),
	};
	sf_struct_base(t, ModifyPrefabEdit, Component, fields);
}

template<> void initType<MakeUniquePrefabEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(MakeUniquePrefabEdit, clientId),
		sf_field(MakeUniquePrefabEdit, prefabName),
		sf_field(MakeUniquePrefabEdit, propIds),
	};
	sf_struct_base(t, MakeUniquePrefabEdit, Component, fields);
}

template<> void initType<AddPropEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(AddPropEdit, prop),
	};
	sf_struct_base(t, AddPropEdit, Component, fields);
}

template<> void initType<ClonePropEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(ClonePropEdit, clientId),
		sf_field(ClonePropEdit, localId),
		sf_field(ClonePropEdit, prop),
	};
	sf_struct_base(t, ClonePropEdit, Component, fields);
}

template<> void initType<MovePropEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(MovePropEdit, propId),
		sf_field(MovePropEdit, transform),
	};
	sf_struct_base(t, MovePropEdit, Component, fields);
}

template<> void initType<RemovePropEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(RemovePropEdit, propId),
	};
	sf_struct_base(t, RemovePropEdit, Component, fields);
}

template<> void initType<DiceRoll>(Type *t)
{
	static Field fields[] = {
		sf_field(DiceRoll, num),
		sf_field(DiceRoll, die),
		sf_field(DiceRoll, bias),
		sf_field(DiceRoll, check),
	};
	sf_struct_base(t, DiceRoll, Component, fields);
}

template<> void initType<BSpline2>(Type *t)
{
	static Field fields[] = {
		sf_field(BSpline2, points),
	};
	sf_struct_base(t, BSpline2, Component, fields);
}

template<> void initType<GradientPoint>(Type *t)
{
	static Field fields[] = {
		sf_field(GradientPoint, t),
		sf_field(GradientPoint, color),
	};
	sf_struct_base(t, GradientPoint, Component, fields);
}

template<> void initType<Gradient>(Type *t)
{
	static Field fields[] = {
		sf_field(Gradient, defaultColor),
		sf_field(Gradient, points),
	};
	sf_struct_base(t, Gradient, Component, fields);
}

template<> void initType<RandomSphere>(Type *t)
{
	static Field fields[] = {
		sf_field(RandomSphere, minTheta),
		sf_field(RandomSphere, maxTheta),
		sf_field(RandomSphere, minPhi),
		sf_field(RandomSphere, maxPhi),
		sf_field(RandomSphere, minRadius),
		sf_field(RandomSphere, maxRadius),
		sf_field(RandomSphere, scale),
	};
	sf_struct_base(t, RandomSphere, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minTheta");
		info.description = "Minimum angle in degrees of the horizontal arc (0-360)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxTheta");
		info.description = "Maximum angle in degrees of the horizontal arc (0-360)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minPhi");
		info.description = "Minimum angle in degrees of the vertical arc (0-180)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxPhi");
		info.description = "Maximums angle in degrees of the vertical arc (0-180)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minRadius");
		info.description = "Minimum distance from the center (in meters)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxRadius");
		info.description = "Maximum distance from the center (in meters)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.description = "Stretches the sphere non-uniformly";
	}
}

template<> void initType<RandomVec3>(Type *t)
{
	static Field fields[] = {
		sf_field(RandomVec3, offset),
		sf_field(RandomVec3, boxExtent),
		sf_field(RandomVec3, sphere),
		sf_field(RandomVec3, rotation),
	};
	sf_struct_base(t, RandomVec3, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "offset");
		info.description = "Base offset/center position";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "boxExtent");
		info.description = "Random X/Y/Z box size in meters";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "sphere");
		info.description = "Random sphere";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.description = "Rotation (X/Y/Z degrees) applied to the final values";
	}
}

template<> void initType<AnimationInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(AnimationInfo, tags),
		sf_field(AnimationInfo, file),
		sf_field(AnimationInfo, weight),
		sf_field(AnimationInfo, loop),
		sf_field(AnimationInfo, speed),
		sf_field(AnimationInfo, speedVariation),
	};
	sf_struct_base(t, AnimationInfo, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "file");
		info.asset = true;
	}
}

template<> void initType<AttachBone>(Type *t)
{
	static Field fields[] = {
		sf_field(AttachBone, name),
		sf_field(AttachBone, boneName),
		sf_field(AttachBone, scale),
	};
	sf_struct_base(t, AttachBone, Component, fields);
}

template<> void initType<ShadowBlob>(Type *t)
{
	static Field fields[] = {
		sf_field(ShadowBlob, boneName),
		sf_field(ShadowBlob, radius),
		sf_field(ShadowBlob, alpha),
		sf_field(ShadowBlob, offset),
	};
	sf_struct_base(t, ShadowBlob, Component, fields);
}

template<> void initType<StarterCard>(Type *t)
{
	static Field fields[] = {
		sf_field(StarterCard, prefabName),
		sf_field(StarterCard, probability),
	};
	sf_struct_base(t, StarterCard, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<Prefab>(Type *t)
{
	static Field fields[] = {
		sf_field(Prefab, name),
		sf_field(Prefab, components),
	};
	sf_struct_base(t, Prefab, Component, fields);
}

template<> void initType<PropTransform>(Type *t)
{
	static Field fields[] = {
		sf_field(PropTransform, position),
		sf_field(PropTransform, offsetY),
		sf_field(PropTransform, rotation),
		sf_field(PropTransform, scale),
	};
	sf_struct_base(t, PropTransform, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "position");
		info.fixedBits = 16;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "offsetY");
		info.fixedBits = 16;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.fixedBits = 6;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.fixedBits = 8;
	}
}

template<> void initType<Prop>(Type *t)
{
	static Field fields[] = {
		sf_field(Prop, id),
		sf_field(Prop, transform),
		sf_field(Prop, prefabName),
	};
	sf_struct_base(t, Prop, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<Card>(Type *t)
{
	static Field fields[] = {
		sf_field(Card, id),
		sf_field(Card, ownerId),
		sf_field(Card, prefabName),
		sf_field(Card, cooldownLeft),
	};
	sf_struct_base(t, Card, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<Status>(Type *t)
{
	static Field fields[] = {
		sf_field(Status, id),
		sf_field(Status, characterId),
		sf_field(Status, prefabName),
		sf_field(Status, cardName),
		sf_field(Status, originalCasterId),
		sf_field(Status, casterId),
		sf_field(Status, turnsLeft),
	};
	sf_struct_base(t, Status, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<Character>(Type *t)
{
	static Field fields[] = {
		sf_field(Character, id),
		sf_field(Character, maxHealth),
		sf_field(Character, health),
		sf_field(Character, prefabName),
		sf_field(Character, selectedCards),
		sf_field(Character, cards),
		sf_field(Character, statuses),
		sf_field(Character, tile),
		sf_field(Character, armor),
	};
	sf_struct_base(t, Character, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<StatusInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusInfo, originalCasterId),
		sf_field(StatusInfo, casterId),
		sf_field(StatusInfo, targetId),
		sf_field(StatusInfo, statusName),
		sf_field(StatusInfo, cardName),
	};
	sf_struct_base(t, StatusInfo, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "statusName");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<SpellInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(SpellInfo, originalCasterId),
		sf_field(SpellInfo, casterId),
		sf_field(SpellInfo, targetId),
		sf_field(SpellInfo, spellName),
		sf_field(SpellInfo, cardName),
	};
	sf_struct_base(t, SpellInfo, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<MeleeInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(MeleeInfo, attackerId),
		sf_field(MeleeInfo, targetId),
		sf_field(MeleeInfo, cardName),
	};
	sf_struct_base(t, MeleeInfo, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<DamageInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(DamageInfo, melee),
		sf_field(DamageInfo, physical),
		sf_field(DamageInfo, magic),
		sf_field(DamageInfo, spellName),
		sf_field(DamageInfo, originalCasterId),
		sf_field(DamageInfo, causeId),
		sf_field(DamageInfo, targetId),
		sf_field(DamageInfo, damageRoll),
	};
	sf_struct_base(t, DamageInfo, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<RollInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(RollInfo, name),
		sf_field(RollInfo, roll),
		sf_field(RollInfo, total),
	};
	sf_struct_base(t, RollInfo, Component, fields);
}

template<> void initType<CastInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(CastInfo, spellInfo),
		sf_field(CastInfo, rolls),
		sf_field(CastInfo, succeeded),
	};
	sf_struct_base(t, CastInfo, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellInfo");
		info.prefab = true;
	}
}

template<> void initType<Waypoint>(Type *t)
{
	static Field fields[] = {
		sf_field(Waypoint, position),
	};
	sf_struct_base(t, Waypoint, Component, fields);
}

}

