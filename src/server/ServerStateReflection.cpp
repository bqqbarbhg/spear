// Generated by misc/gen-server-reflection.py
#include "ServerStateReflection.h"
#include "ServerState.h"
#include "sf/Reflection.h"

namespace sv { ReflectionInfo &addTypeReflectionInfo(sf::Type *type, const sf::String &fieldName); }

namespace sf {
using namespace sv;

template<> void initType<Component>(Type *t)
{
	static PolymorphType polys[] = {
		sf_poly(Component, DynamicModel, DynamicModelComponent),
		sf_poly(Component, TileModel, TileModelComponent),
		sf_poly(Component, PointLight, PointLightComponent),
		sf_poly(Component, ParticleSystem, ParticleSystemComponent),
		sf_poly(Component, Character, CharacterComponent),
		sf_poly(Component, CharacterModel, CharacterModelComponent),
		sf_poly(Component, TapArea, TapAreaComponent),
		sf_poly(Component, BlobShadow, BlobShadowComponent),
		sf_poly(Component, Card, CardComponent),
		sf_poly(Component, CardAttach, CardAttachComponent),
		sf_poly(Component, CardStatus, CardStatusComponent),
		sf_poly(Component, CardMelee, CardMeleeComponent),
		sf_poly(Component, Projectile, ProjectileComponent),
		sf_poly(Component, DamageOnTurnStart, DamageOnTurnStartComponent),
		sf_poly(Component, CastOnTurnStart, CastOnTurnStartComponent),
		sf_poly(Component, CastOnReceiveDamage, CastOnReceiveDamageComponent),
		sf_poly(Component, CastOnDealDamage, CastOnDealDamageComponent),
		sf_poly(Component, ResistDamage, ResistDamageComponent),
		sf_poly(Component, CardCast, CardCastComponent),
		sf_poly(Component, Spell, SpellComponent),
		sf_poly(Component, SpellDamage, SpellDamageComponent),
		sf_poly(Component, SpellStatus, SpellStatusComponent),
		sf_poly(Component, Status, StatusComponent),
		sf_poly(Component, CharacterTemplate, CharacterTemplateComponent),
		sf_poly(Component, TileArea, TileAreaComponent),
		sf_poly(Component, Effect, EffectComponent),
		sf_poly(Component, Sound, SoundComponent),
		sf_poly(Component, RoomConnection, RoomConnectionComponent),
	};
	sf_struct_poly(t, Component, type, { }, polys);
}

template<> void initType<Event>(Type *t)
{
	static PolymorphType polys[] = {
		sf_poly(Event, AllocateId, AllocateIdEvent),
		sf_poly(Event, CardCooldownTick, CardCooldownTickEvent),
		sf_poly(Event, StatusAdd, StatusAddEvent),
		sf_poly(Event, StatusExtend, StatusExtendEvent),
		sf_poly(Event, StatusTick, StatusTickEvent),
		sf_poly(Event, StatusRemove, StatusRemoveEvent),
		sf_poly(Event, ResistDamage, ResistDamageEvent),
		sf_poly(Event, CastSpell, CastSpellEvent),
		sf_poly(Event, MeleeAttack, MeleeAttackEvent),
		sf_poly(Event, Damage, DamageEvent),
		sf_poly(Event, LoadPrefab, LoadPrefabEvent),
		sf_poly(Event, ReloadPrefab, ReloadPrefabEvent),
		sf_poly(Event, MakeUniquePrefab, MakeUniquePrefabEvent),
		sf_poly(Event, RemoveGarbageIds, RemoveGarbageIdsEvent),
		sf_poly(Event, RemoveGarbagePrefabs, RemoveGarbagePrefabsEvent),
		sf_poly(Event, AddProp, AddPropEvent),
		sf_poly(Event, RemoveProp, RemovePropEvent),
		sf_poly(Event, ReplaceLocalProp, ReplaceLocalPropEvent),
		sf_poly(Event, AddCharacter, AddCharacterEvent),
		sf_poly(Event, AddCard, AddCardEvent),
		sf_poly(Event, MoveProp, MovePropEvent),
		sf_poly(Event, GiveCard, GiveCardEvent),
		sf_poly(Event, SelectCard, SelectCardEvent),
		sf_poly(Event, UnselectCard, UnselectCardEvent),
		sf_poly(Event, AddCharacterToSpawn, AddCharacterToSpawn),
		sf_poly(Event, SelectCharacterToSpawn, SelectCharacterToSpawnEvent),
		sf_poly(Event, Move, MoveEvent),
		sf_poly(Event, TurnUpdate, TurnUpdateEvent),
	};
	sf_struct_poly(t, Event, type, { }, polys);
}

template<> void initType<Edit>(Type *t)
{
	static PolymorphType polys[] = {
		sf_poly(Edit, PreloadPrefab, PreloadPrefabEdit),
		sf_poly(Edit, ModifyPrefab, ModifyPrefabEdit),
		sf_poly(Edit, MakeUniquePrefab, MakeUniquePrefabEdit),
		sf_poly(Edit, AddProp, AddPropEdit),
		sf_poly(Edit, CloneProp, ClonePropEdit),
		sf_poly(Edit, MoveProp, MovePropEdit),
		sf_poly(Edit, RemoveProp, RemovePropEdit),
		sf_poly(Edit, AddCharacter, AddCharacterEdit),
	};
	sf_struct_poly(t, Edit, type, { }, polys);
}

template<> void initType<Action>(Type *t)
{
	static PolymorphType polys[] = {
		sf_poly(Action, Move, MoveAction),
		sf_poly(Action, SelectCard, SelectCardAction),
		sf_poly(Action, GiveCard, GiveCardAction),
		sf_poly(Action, EndTurn, EndTurnAction),
		sf_poly(Action, UseCard, UseCardAction),
	};
	sf_struct_poly(t, Action, type, { }, polys);
}

template<> void initType<DynamicModelComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(DynamicModelComponent, model),
		sf_field(DynamicModelComponent, shadowModel),
		sf_field(DynamicModelComponent, material),
		sf_field(DynamicModelComponent, position),
		sf_field(DynamicModelComponent, rotation),
		sf_field(DynamicModelComponent, scale),
		sf_field(DynamicModelComponent, stretch),
		sf_field(DynamicModelComponent, tintColor),
		sf_field(DynamicModelComponent, castShadows),
	};
	sf_struct_base(t, DynamicModelComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "model");
		info.description = "Model .fbx asset";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "shadowModel");
		info.description = "Model .fbx used for shadow instead of 'model'";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "material");
		info.description = "Material used fo the asset";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "position");
		info.description = "Offset (in meters) of the model relative to the entity";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.description = "Rotation (XYZ in degrees) of the model relative to the entity";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.description = "Uniform scaling applied to the model";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "stretch");
		info.description = "Non-uniform scaling in entity's local X/Y/Z directions";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "tintColor");
		info.description = "Modifies the base color of the model's material";
		info.color = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "castShadows");
		info.description = "Does the model cast shadows?";
	}
}

template<> void initType<TileModelComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(TileModelComponent, model),
		sf_field(TileModelComponent, shadowModel),
		sf_field(TileModelComponent, material),
		sf_field(TileModelComponent, position),
		sf_field(TileModelComponent, rotation),
		sf_field(TileModelComponent, scale),
		sf_field(TileModelComponent, stretch),
		sf_field(TileModelComponent, tintColor),
		sf_field(TileModelComponent, castShadows),
	};
	sf_struct_base(t, TileModelComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "model");
		info.description = "Model .fbx asset";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "shadowModel");
		info.description = "Model .fbx used for shadow instead of 'model'";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "material");
		info.description = "Material used fo the asset";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "position");
		info.description = "Offset (in meters) of the model relative to the entity";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.description = "Rotation (XYZ in degrees) of the model relative to the entity";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.description = "Uniform scaling applied to the model";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "stretch");
		info.description = "Non-uniform scaling in entity's local X/Y/Z directions";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "tintColor");
		info.description = "Modifies the base color of the model's material";
		info.color = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "castShadows");
		info.description = "Does the model cast shadows?";
	}
}

template<> void initType<PointLightComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(PointLightComponent, color),
		sf_field(PointLightComponent, intensity),
		sf_field(PointLightComponent, radius),
		sf_field(PointLightComponent, position),
		sf_field(PointLightComponent, hasShadows),
		sf_field(PointLightComponent, minQuality),
		sf_field(PointLightComponent, fadeInTime),
		sf_field(PointLightComponent, fadeOutTime),
	};
	sf_struct_base(t, PointLightComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "color");
		info.description = "Color of the light";
		info.color = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "intensity");
		info.description = "Brightness of the light";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "radius");
		info.description = "Maximum eistance in meters that the light can reach";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "position");
		info.description = "Offset (in meters) of the light in the entity";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "hasShadows");
		info.description = "Does this light have shadows";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minQuality");
		info.description = "Minimum quality level needed for this light (0-10)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "fadeInTime");
		info.description = "Time to fade in when spawning";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "fadeOutTime");
		info.description = "Time to fade out when spawning";
	}
}

template<> void initType<ParticleSystemComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(ParticleSystemComponent, texture),
		sf_field(ParticleSystemComponent, frameCount),
		sf_field(ParticleSystemComponent, timeStep),
		sf_field(ParticleSystemComponent, prewarmTime),
		sf_field(ParticleSystemComponent, updateRadius),
		sf_field(ParticleSystemComponent, cullPadding),
		sf_field(ParticleSystemComponent, updateOutOfCamera),
		sf_field(ParticleSystemComponent, renderOrder),
		sf_field(ParticleSystemComponent, spawnTime),
		sf_field(ParticleSystemComponent, spawnTimeVariance),
		sf_field(ParticleSystemComponent, burstAmount),
		sf_field(ParticleSystemComponent, burstAmountVariance),
		sf_field(ParticleSystemComponent, emitterOnTime),
		sf_field(ParticleSystemComponent, localSpace),
		sf_field(ParticleSystemComponent, instantDelete),
		sf_field(ParticleSystemComponent, emitPosition),
		sf_field(ParticleSystemComponent, emitVelocity),
		sf_field(ParticleSystemComponent, emitVelocityAttractorOffset),
		sf_field(ParticleSystemComponent, emitVelocityAttractorStrength),
		sf_field(ParticleSystemComponent, gravityPoints),
		sf_field(ParticleSystemComponent, drag),
		sf_field(ParticleSystemComponent, gravity),
		sf_field(ParticleSystemComponent, size),
		sf_field(ParticleSystemComponent, sizeVariance),
		sf_field(ParticleSystemComponent, lifeTime),
		sf_field(ParticleSystemComponent, lifeTimeVariance),
		sf_field(ParticleSystemComponent, scaleSpline),
		sf_field(ParticleSystemComponent, alphaSpline),
		sf_field(ParticleSystemComponent, additiveSpline),
		sf_field(ParticleSystemComponent, erosionSpline),
		sf_field(ParticleSystemComponent, gradient),
		sf_field(ParticleSystemComponent, frameRate),
		sf_field(ParticleSystemComponent, relativeFrameRate),
		sf_field(ParticleSystemComponent, randomStartFrame),
		sf_field(ParticleSystemComponent, rotation),
		sf_field(ParticleSystemComponent, rotationVariance),
		sf_field(ParticleSystemComponent, spin),
		sf_field(ParticleSystemComponent, spinVariance),
	};
	sf_struct_base(t, ParticleSystemComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "texture");
		info.description = "Texture used for the effect";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "frameCount");
		info.description = "Number of frames in a sprite sheet";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "timeStep");
		info.description = "How large simulation steps to do, smaller values are heavier but more accurate";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prewarmTime");
		info.description = "Time to simulate after spawning the effect";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "updateRadius");
		info.description = "Size of the \"active area\" of this particle effect";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cullPadding");
		info.description = "How much to \"pad\" the area for culling, increase if the effect disappears";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "updateOutOfCamera");
		info.description = "Update even if not visible in the camera";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "renderOrder");
		info.description = "Smaller render order values are rendered first";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spawnTime");
		info.description = "Time in seconds between spawning particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spawnTimeVariance");
		info.description = "Random extra time between spawns";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "burstAmount");
		info.description = "How many particles to spawn in the beginning";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "burstAmountVariance");
		info.description = "Additional random particle amount to spawn in the beginning";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitterOnTime");
		info.description = "How long to emit particles (negative for infinite, zero for no emit)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "localSpace");
		info.description = "Simualte particles in entity-local space";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "instantDelete");
		info.description = "Delete particles immediately when the entity is removed";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitPosition");
		info.description = "Random position for new particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitVelocity");
		info.description = "Random velocity for new particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitVelocityAttractorOffset");
		info.description = "Position to apply extra velocity towards/away from";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "emitVelocityAttractorStrength");
		info.description = "Extra velocity towards (< 0) or away (> 1) from attractor offset";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "gravityPoints");
		info.description = "Gravity points to attract/repel particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "drag");
		info.description = "Air resistance slowing particles from moving";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "gravity");
		info.description = "Linear force applied to all particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "size");
		info.description = "Base size of particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "sizeVariance");
		info.description = "Random additional size for individual particles";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "lifeTime");
		info.description = "Time in seconds the particles live";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "lifeTimeVariance");
		info.description = "Random additional per-particle life time";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scaleSpline");
		info.description = "Particle scale over particle lifetime";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "alphaSpline");
		info.description = "Particle alpha over particle lifetime";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "additiveSpline");
		info.description = "Additive blending over particle lifetime";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "erosionSpline");
		info.description = "Particle alpha erosion amount";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "gradient");
		info.description = "Color gradient over particle lifetime";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "frameRate");
		info.description = "Texture animation speed in frames per second";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "relativeFrameRate");
		info.description = "Ties the tie frame rate to particle life time (for synchronization)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "randomStartFrame");
		info.description = "Start from a random frame in the sprite sheet";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.description = "Base rotation of the particles in degrees";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotationVariance");
		info.description = "Random per-particle extra rotation of the particles in degrees";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spin");
		info.description = "Rotation speed for the particles in degrees";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spinVariance");
		info.description = "Random per-particle speed for the particles in degrees";
	}
}

template<> void initType<CharacterComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CharacterComponent, name),
		sf_field(CharacterComponent, description),
		sf_field(CharacterComponent, image),
		sf_field(CharacterComponent, maxHealth),
		sf_field(CharacterComponent, baseArmor),
		sf_field(CharacterComponent, minWeightDice),
		sf_field(CharacterComponent, maxWeightDice),
		sf_field(CharacterComponent, skillSlots),
		sf_field(CharacterComponent, spellSlots),
		sf_field(CharacterComponent, itemSlots),
		sf_field(CharacterComponent, baseSpeed),
		sf_field(CharacterComponent, centerOffset),
	};
	sf_struct_base(t, CharacterComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "description");
		info.multiline = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "image");
		info.asset = true;
	}
}

template<> void initType<CharacterModelComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CharacterModelComponent, modelName),
		sf_field(CharacterModelComponent, materials),
		sf_field(CharacterModelComponent, scale),
		sf_field(CharacterModelComponent, animations),
		sf_field(CharacterModelComponent, attachBones),
	};
	sf_struct_base(t, CharacterModelComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "modelName");
		info.description = "Character model asset";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "materials");
		info.description = "Material asset links";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.description = "Scale of the character";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "attachBones");
		info.description = "Bone mapping for attaching objects";
	}
}

template<> void initType<TapAreaComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(TapAreaComponent, offset),
		sf_field(TapAreaComponent, extent),
	};
	sf_struct_base(t, TapAreaComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "offset");
		info.description = "Offset from the character";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "extent");
		info.description = "Size of the clickable/tappable box";
	}
}

template<> void initType<BlobShadowComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(BlobShadowComponent, blobs),
	};
	sf_struct_base(t, BlobShadowComponent, Component, fields);
}

template<> void initType<CardComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardComponent, image),
		sf_field(CardComponent, name),
		sf_field(CardComponent, description),
		sf_field(CardComponent, cooldown),
		sf_field(CardComponent, melee),
		sf_field(CardComponent, skill),
		sf_field(CardComponent, spell),
		sf_field(CardComponent, item),
	};
	sf_struct_base(t, CardComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "image");
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "description");
		info.multiline = true;
	}
}

template<> void initType<CardAttachComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardAttachComponent, prefabName),
		sf_field(CardAttachComponent, boneName),
		sf_field(CardAttachComponent, scale),
		sf_field(CardAttachComponent, offset),
		sf_field(CardAttachComponent, animationTags),
	};
	sf_struct_base(t, CardAttachComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<CardStatusComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardStatusComponent, statusName),
	};
	sf_struct_base(t, CardStatusComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "statusName");
		info.prefab = true;
	}
}

template<> void initType<CardMeleeComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardMeleeComponent, hitRoll),
	};
	sf_struct_base(t, CardMeleeComponent, Component, fields);
}

template<> void initType<ProjectileComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(ProjectileComponent, prefabName),
		sf_field(ProjectileComponent, hitEffect),
		sf_field(ProjectileComponent, flightSpeed),
	};
	sf_struct_base(t, ProjectileComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "hitEffect");
		info.prefab = true;
	}
}

template<> void initType<DamageOnTurnStartComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(DamageOnTurnStartComponent, damageRoll),
	};
	sf_struct_base(t, DamageOnTurnStartComponent, Component, fields);
}

template<> void initType<CastOnTurnStartComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CastOnTurnStartComponent, spellName),
	};
	sf_struct_base(t, CastOnTurnStartComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<CastOnReceiveDamageComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CastOnReceiveDamageComponent, onMelee),
		sf_field(CastOnReceiveDamageComponent, onSpell),
		sf_field(CastOnReceiveDamageComponent, spellName),
	};
	sf_struct_base(t, CastOnReceiveDamageComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<CastOnDealDamageComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CastOnDealDamageComponent, onMelee),
		sf_field(CastOnDealDamageComponent, onSpell),
		sf_field(CastOnDealDamageComponent, spellName),
	};
	sf_struct_base(t, CastOnDealDamageComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<ResistDamageComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(ResistDamageComponent, onSpell),
		sf_field(ResistDamageComponent, onMelee),
		sf_field(ResistDamageComponent, resistAmount),
		sf_field(ResistDamageComponent, successRoll),
		sf_field(ResistDamageComponent, effectName),
	};
	sf_struct_base(t, ResistDamageComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "effectName");
		info.prefab = true;
	}
}

template<> void initType<CardCastComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardCastComponent, spellName),
	};
	sf_struct_base(t, CardCastComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
}

template<> void initType<SpellComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(SpellComponent, castEffect),
		sf_field(SpellComponent, successRoll),
	};
	sf_struct_base(t, SpellComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "castEffect");
		info.prefab = true;
	}
}

template<> void initType<SpellDamageComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(SpellDamageComponent, damageRoll),
	};
	sf_struct_base(t, SpellDamageComponent, Component, fields);
}

template<> void initType<SpellStatusComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(SpellStatusComponent, statusName),
	};
	sf_struct_base(t, SpellStatusComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "statusName");
		info.prefab = true;
	}
}

template<> void initType<StatusComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusComponent, turnsRoll),
		sf_field(StatusComponent, startEffect),
		sf_field(StatusComponent, activeEffect),
		sf_field(StatusComponent, tickEffect),
		sf_field(StatusComponent, endEffect),
		sf_field(StatusComponent, stacks),
	};
	sf_struct_base(t, StatusComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "startEffect");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "activeEffect");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "tickEffect");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "endEffect");
		info.prefab = true;
	}
}

template<> void initType<CharacterTemplateComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(CharacterTemplateComponent, name),
		sf_field(CharacterTemplateComponent, description),
		sf_field(CharacterTemplateComponent, characterPrefab),
		sf_field(CharacterTemplateComponent, starterCards),
	};
	sf_struct_base(t, CharacterTemplateComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "description");
		info.multiline = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "characterPrefab");
		info.prefab = true;
	}
}

template<> void initType<TileAreaComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(TileAreaComponent, minCorner),
		sf_field(TileAreaComponent, maxCorner),
	};
	sf_struct_base(t, TileAreaComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minCorner");
		info.description = "Top-left corner of the tile area (in meters/tiles)";
		info.fixedBits = 16;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxCorner");
		info.description = "Bottom-right corner of the tile area (in meters/tiles)";
		info.fixedBits = 16;
	}
}

template<> void initType<EffectComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(EffectComponent, lifeTime),
		sf_field(EffectComponent, grounded),
	};
	sf_struct_base(t, EffectComponent, Component, fields);
}

template<> void initType<SoundComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(SoundComponent, sounds),
		sf_field(SoundComponent, volume),
		sf_field(SoundComponent, volumeVariance),
		sf_field(SoundComponent, pitch),
		sf_field(SoundComponent, pitchVariance),
		sf_field(SoundComponent, loop),
		sf_field(SoundComponent, offset),
	};
	sf_struct_base(t, SoundComponent, Component, fields);
}

template<> void initType<RoomConnectionComponent>(Type *t)
{
	static Field fields[] = {
		sf_field(RoomConnectionComponent, minCorner),
		sf_field(RoomConnectionComponent, maxCorner),
		sf_field(RoomConnectionComponent, connectionType),
	};
	sf_struct_base(t, RoomConnectionComponent, Component, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minCorner");
		info.description = "Top-left corner of the room connection (in meters/tiles)";
		info.fixedBits = 16;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxCorner");
		info.description = "Bottom-right corner of the room connection (in meters/tiles)";
		info.fixedBits = 16;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "connectionType");
		info.description = "Name of the connection that can be matched with this";
	}
}

template<> void initType<AllocateIdEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AllocateIdEvent, id),
	};
	sf_struct_base(t, AllocateIdEvent, Event, fields);
}

template<> void initType<CardCooldownTickEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(CardCooldownTickEvent, cardId),
	};
	sf_struct_base(t, CardCooldownTickEvent, Event, fields);
}

template<> void initType<StatusAddEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusAddEvent, turnsRoll),
		sf_field(StatusAddEvent, status),
	};
	sf_struct_base(t, StatusAddEvent, Event, fields);
}

template<> void initType<StatusExtendEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusExtendEvent, statusId),
		sf_field(StatusExtendEvent, turnsRoll),
	};
	sf_struct_base(t, StatusExtendEvent, Event, fields);
}

template<> void initType<StatusTickEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusTickEvent, statusId),
	};
	sf_struct_base(t, StatusTickEvent, Event, fields);
}

template<> void initType<StatusRemoveEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusRemoveEvent, statusId),
	};
	sf_struct_base(t, StatusRemoveEvent, Event, fields);
}

template<> void initType<ResistDamageEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(ResistDamageEvent, cardName),
		sf_field(ResistDamageEvent, effectName),
		sf_field(ResistDamageEvent, resistAmount),
		sf_field(ResistDamageEvent, resistDamage),
		sf_field(ResistDamageEvent, successRoll),
		sf_field(ResistDamageEvent, success),
	};
	sf_struct_base(t, ResistDamageEvent, Event, fields);
}

template<> void initType<CastSpellEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(CastSpellEvent, spellInfo),
		sf_field(CastSpellEvent, successRoll),
	};
	sf_struct_base(t, CastSpellEvent, Event, fields);
}

template<> void initType<MeleeAttackEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(MeleeAttackEvent, meleeInfo),
		sf_field(MeleeAttackEvent, hitRoll),
	};
	sf_struct_base(t, MeleeAttackEvent, Event, fields);
}

template<> void initType<DamageEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(DamageEvent, damageInfo),
		sf_field(DamageEvent, damageRoll),
		sf_field(DamageEvent, finalDamage),
		sf_field(DamageEvent, meleeArmor),
	};
	sf_struct_base(t, DamageEvent, Event, fields);
}

template<> void initType<LoadPrefabEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(LoadPrefabEvent, prefab),
	};
	sf_struct_base(t, LoadPrefabEvent, Event, fields);
}

template<> void initType<ReloadPrefabEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(ReloadPrefabEvent, prefab),
	};
	sf_struct_base(t, ReloadPrefabEvent, Event, fields);
}

template<> void initType<MakeUniquePrefabEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(MakeUniquePrefabEvent, clientId),
		sf_field(MakeUniquePrefabEvent, prefabName),
		sf_field(MakeUniquePrefabEvent, uniquePrefabName),
		sf_field(MakeUniquePrefabEvent, propIds),
	};
	sf_struct_base(t, MakeUniquePrefabEvent, Event, fields);
}

template<> void initType<RemoveGarbageIdsEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(RemoveGarbageIdsEvent, ids),
	};
	sf_struct_base(t, RemoveGarbageIdsEvent, Event, fields);
}

template<> void initType<RemoveGarbagePrefabsEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(RemoveGarbagePrefabsEvent, names),
	};
	sf_struct_base(t, RemoveGarbagePrefabsEvent, Event, fields);
}

template<> void initType<AddPropEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AddPropEvent, prop),
	};
	sf_struct_base(t, AddPropEvent, Event, fields);
}

template<> void initType<RemovePropEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(RemovePropEvent, propId),
	};
	sf_struct_base(t, RemovePropEvent, Event, fields);
}

template<> void initType<ReplaceLocalPropEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(ReplaceLocalPropEvent, clientId),
		sf_field(ReplaceLocalPropEvent, localId),
		sf_field(ReplaceLocalPropEvent, prop),
	};
	sf_struct_base(t, ReplaceLocalPropEvent, Event, fields);
}

template<> void initType<AddCharacterEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AddCharacterEvent, character),
	};
	sf_struct_base(t, AddCharacterEvent, Event, fields);
}

template<> void initType<AddCardEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AddCardEvent, card),
	};
	sf_struct_base(t, AddCardEvent, Event, fields);
}

template<> void initType<MovePropEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(MovePropEvent, propId),
		sf_field(MovePropEvent, transform),
	};
	sf_struct_base(t, MovePropEvent, Event, fields);
}

template<> void initType<GiveCardEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(GiveCardEvent, cardId),
		sf_field(GiveCardEvent, previousOwnerId),
		sf_field(GiveCardEvent, ownerId),
	};
	sf_struct_base(t, GiveCardEvent, Event, fields);
}

template<> void initType<SelectCardEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(SelectCardEvent, ownerId),
		sf_field(SelectCardEvent, cardId),
		sf_field(SelectCardEvent, slot),
	};
	sf_struct_base(t, SelectCardEvent, Event, fields);
}

template<> void initType<UnselectCardEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(UnselectCardEvent, ownerId),
		sf_field(UnselectCardEvent, prevCardId),
		sf_field(UnselectCardEvent, slot),
	};
	sf_struct_base(t, UnselectCardEvent, Event, fields);
}

template<> void initType<AddCharacterToSpawn>(Type *t)
{
	static Field fields[] = {
		sf_field(AddCharacterToSpawn, selectPrefab),
		sf_field(AddCharacterToSpawn, count),
	};
	sf_struct_base(t, AddCharacterToSpawn, Event, fields);
}

template<> void initType<SelectCharacterToSpawnEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(SelectCharacterToSpawnEvent, selectPrefab),
		sf_field(SelectCharacterToSpawnEvent, playerId),
	};
	sf_struct_base(t, SelectCharacterToSpawnEvent, Event, fields);
}

template<> void initType<MoveEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(MoveEvent, characterId),
		sf_field(MoveEvent, position),
		sf_field(MoveEvent, waypoints),
	};
	sf_struct_base(t, MoveEvent, Event, fields);
}

template<> void initType<TurnUpdateEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(TurnUpdateEvent, turnInfo),
	};
	sf_struct_base(t, TurnUpdateEvent, Event, fields);
}

template<> void initType<PreloadPrefabEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(PreloadPrefabEdit, prefabName),
	};
	sf_struct_base(t, PreloadPrefabEdit, Edit, fields);
}

template<> void initType<ModifyPrefabEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(ModifyPrefabEdit, prefab),
	};
	sf_struct_base(t, ModifyPrefabEdit, Edit, fields);
}

template<> void initType<MakeUniquePrefabEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(MakeUniquePrefabEdit, clientId),
		sf_field(MakeUniquePrefabEdit, prefabName),
		sf_field(MakeUniquePrefabEdit, propIds),
	};
	sf_struct_base(t, MakeUniquePrefabEdit, Edit, fields);
}

template<> void initType<AddPropEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(AddPropEdit, prop),
	};
	sf_struct_base(t, AddPropEdit, Edit, fields);
}

template<> void initType<ClonePropEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(ClonePropEdit, clientId),
		sf_field(ClonePropEdit, localId),
		sf_field(ClonePropEdit, prop),
	};
	sf_struct_base(t, ClonePropEdit, Edit, fields);
}

template<> void initType<MovePropEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(MovePropEdit, propId),
		sf_field(MovePropEdit, transform),
	};
	sf_struct_base(t, MovePropEdit, Edit, fields);
}

template<> void initType<RemovePropEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(RemovePropEdit, propId),
	};
	sf_struct_base(t, RemovePropEdit, Edit, fields);
}

template<> void initType<AddCharacterEdit>(Type *t)
{
	static Field fields[] = {
		sf_field(AddCharacterEdit, character),
	};
	sf_struct_base(t, AddCharacterEdit, Edit, fields);
}

template<> void initType<MoveAction>(Type *t)
{
	static Field fields[] = {
		sf_field(MoveAction, characterId),
		sf_field(MoveAction, tile),
		sf_field(MoveAction, waypoints),
	};
	sf_struct_base(t, MoveAction, Action, fields);
}

template<> void initType<SelectCardAction>(Type *t)
{
	static Field fields[] = {
		sf_field(SelectCardAction, ownerId),
		sf_field(SelectCardAction, cardId),
		sf_field(SelectCardAction, slot),
	};
	sf_struct_base(t, SelectCardAction, Action, fields);
}

template<> void initType<GiveCardAction>(Type *t)
{
	static Field fields[] = {
		sf_field(GiveCardAction, ownerId),
		sf_field(GiveCardAction, cardId),
	};
	sf_struct_base(t, GiveCardAction, Action, fields);
}

template<> void initType<EndTurnAction>(Type *t)
{
	static Field fields[] = {
		sf_field(EndTurnAction, characterId),
	};
	sf_struct_base(t, EndTurnAction, Action, fields);
}

template<> void initType<UseCardAction>(Type *t)
{
	static Field fields[] = {
		sf_field(UseCardAction, characterId),
		sf_field(UseCardAction, targetId),
		sf_field(UseCardAction, cardId),
	};
	sf_struct_base(t, UseCardAction, Action, fields);
}

template<> void initType<DiceRoll>(Type *t)
{
	static Field fields[] = {
		sf_field(DiceRoll, num),
		sf_field(DiceRoll, die),
		sf_field(DiceRoll, bias),
		sf_field(DiceRoll, check),
	};
	sf_struct(t, DiceRoll, fields);
}

template<> void initType<BSpline2>(Type *t)
{
	static Field fields[] = {
		sf_field(BSpline2, points),
	};
	sf_struct(t, BSpline2, fields);
}

template<> void initType<GradientPoint>(Type *t)
{
	static Field fields[] = {
		sf_field(GradientPoint, t),
		sf_field(GradientPoint, color),
	};
	sf_struct(t, GradientPoint, fields);
}

template<> void initType<Gradient>(Type *t)
{
	static Field fields[] = {
		sf_field(Gradient, defaultColor),
		sf_field(Gradient, points),
	};
	sf_struct(t, Gradient, fields);
}

template<> void initType<RandomSphere>(Type *t)
{
	static Field fields[] = {
		sf_field(RandomSphere, minTheta),
		sf_field(RandomSphere, maxTheta),
		sf_field(RandomSphere, minPhi),
		sf_field(RandomSphere, maxPhi),
		sf_field(RandomSphere, minRadius),
		sf_field(RandomSphere, maxRadius),
		sf_field(RandomSphere, scale),
	};
	sf_struct(t, RandomSphere, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minTheta");
		info.description = "Minimum angle in degrees of the horizontal arc (0-360)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxTheta");
		info.description = "Maximum angle in degrees of the horizontal arc (0-360)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minPhi");
		info.description = "Minimum angle in degrees of the vertical arc (0-180)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxPhi");
		info.description = "Maximums angle in degrees of the vertical arc (0-180)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "minRadius");
		info.description = "Minimum distance from the center (in meters)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "maxRadius");
		info.description = "Maximum distance from the center (in meters)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.description = "Stretches the sphere non-uniformly";
	}
}

template<> void initType<RandomVec3>(Type *t)
{
	static Field fields[] = {
		sf_field(RandomVec3, offset),
		sf_field(RandomVec3, boxExtent),
		sf_field(RandomVec3, sphere),
		sf_field(RandomVec3, rotation),
	};
	sf_struct(t, RandomVec3, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "offset");
		info.description = "Base offset/center position";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "boxExtent");
		info.description = "Random X/Y/Z box size in meters";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "sphere");
		info.description = "Random sphere";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.description = "Rotation (X/Y/Z degrees) applied to the final values";
	}
}

template<> void initType<GravityPoint>(Type *t)
{
	static Field fields[] = {
		sf_field(GravityPoint, position),
		sf_field(GravityPoint, radius),
		sf_field(GravityPoint, strength),
	};
	sf_struct(t, GravityPoint, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "position");
		info.description = "Position of the gravity in the local space";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "radius");
		info.description = "Distance where the force is at maximum";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "strength");
		info.description = "Strength of the gravitational pull (negative to push away)";
	}
}

template<> void initType<AnimationEvent>(Type *t)
{
	static Field fields[] = {
		sf_field(AnimationEvent, name),
		sf_field(AnimationEvent, time),
	};
	sf_struct(t, AnimationEvent, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "name");
		info.description = "Name of the event";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "time");
		info.description = "Time into the animation when the event is triggered";
	}
}

template<> void initType<AnimationInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(AnimationInfo, tags),
		sf_field(AnimationInfo, file),
		sf_field(AnimationInfo, events),
		sf_field(AnimationInfo, weight),
		sf_field(AnimationInfo, loop),
		sf_field(AnimationInfo, speed),
		sf_field(AnimationInfo, speedVariation),
		sf_field(AnimationInfo, fadeInDuration),
		sf_field(AnimationInfo, fadeOutDuration),
		sf_field(AnimationInfo, startTime),
	};
	sf_struct(t, AnimationInfo, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "tags");
		info.description = "Tags for when to play the animation";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "file");
		info.description = "Animation .fbx asset file";
		info.asset = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "events");
		info.description = "Events in the animation";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "weight");
		info.description = "How often to play the animation (for equal tags)";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "loop");
		info.description = "Should the animation blend the ending with the beginning";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "speed");
		info.description = "How fast to play the animation";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "speedVariation");
		info.description = "Random playback speed variation added on top of speed";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "fadeInDuration");
		info.description = "Time in seconds for the animation to fade in";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "fadeOutDuration");
		info.description = "Time in seconds for the animation to fade out";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "startTime");
		info.description = "Offset time to start into the animation";
	}
}

template<> void initType<AttachBone>(Type *t)
{
	static Field fields[] = {
		sf_field(AttachBone, name),
		sf_field(AttachBone, boneName),
		sf_field(AttachBone, scale),
	};
	sf_struct(t, AttachBone, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "name");
		info.description = "Name of the attachment point eg. ItemL";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "boneName");
		info.description = "Name of the .fbx bone eg. bnd_object";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.description = "Scale factor for attached objects";
	}
}

template<> void initType<CharacterMaterial>(Type *t)
{
	static Field fields[] = {
		sf_field(CharacterMaterial, name),
		sf_field(CharacterMaterial, material),
	};
	sf_struct(t, CharacterMaterial, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "name");
		info.description = "Name of the material in the .fbx file";
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "material");
		info.description = "Material asset name";
		info.asset = true;
	}
}

template<> void initType<ShadowBlob>(Type *t)
{
	static Field fields[] = {
		sf_field(ShadowBlob, boneName),
		sf_field(ShadowBlob, radius),
		sf_field(ShadowBlob, alpha),
		sf_field(ShadowBlob, fadeDistance),
		sf_field(ShadowBlob, offset),
	};
	sf_struct(t, ShadowBlob, fields);
}

template<> void initType<StarterCard>(Type *t)
{
	static Field fields[] = {
		sf_field(StarterCard, prefabName),
		sf_field(StarterCard, probability),
	};
	sf_struct(t, StarterCard, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<SoundInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(SoundInfo, assetName),
	};
	sf_struct(t, SoundInfo, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "assetName");
		info.asset = true;
	}
}

template<> void initType<Prefab>(Type *t)
{
	static Field fields[] = {
		sf_field(Prefab, name),
		sf_field(Prefab, components),
	};
	sf_struct(t, Prefab, fields);
}

template<> void initType<PropTransform>(Type *t)
{
	static Field fields[] = {
		sf_field(PropTransform, position),
		sf_field(PropTransform, offsetY),
		sf_field(PropTransform, rotation),
		sf_field(PropTransform, scale),
	};
	sf_struct(t, PropTransform, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "position");
		info.fixedBits = 16;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "offsetY");
		info.fixedBits = 16;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "rotation");
		info.fixedBits = 6;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "scale");
		info.fixedBits = 8;
	}
}

template<> void initType<Prop>(Type *t)
{
	static Field fields[] = {
		sf_field(Prop, id),
		sf_field(Prop, transform),
		sf_field(Prop, prefabName),
	};
	sf_struct(t, Prop, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<Card>(Type *t)
{
	static Field fields[] = {
		sf_field(Card, id),
		sf_field(Card, ownerId),
		sf_field(Card, prefabName),
		sf_field(Card, cooldownLeft),
	};
	sf_struct(t, Card, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<Status>(Type *t)
{
	static Field fields[] = {
		sf_field(Status, id),
		sf_field(Status, characterId),
		sf_field(Status, prefabName),
		sf_field(Status, cardName),
		sf_field(Status, originalCasterId),
		sf_field(Status, casterId),
		sf_field(Status, turnsLeft),
	};
	sf_struct(t, Status, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<Character>(Type *t)
{
	static Field fields[] = {
		sf_field(Character, id),
		sf_field(Character, maxHealth),
		sf_field(Character, health),
		sf_field(Character, prefabName),
		sf_field(Character, selectedCards),
		sf_field(Character, cards),
		sf_field(Character, statuses),
		sf_field(Character, tile),
		sf_field(Character, armor),
	};
	sf_struct(t, Character, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "prefabName");
		info.prefab = true;
	}
}

template<> void initType<StatusInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(StatusInfo, originalCasterId),
		sf_field(StatusInfo, casterId),
		sf_field(StatusInfo, targetId),
		sf_field(StatusInfo, statusName),
		sf_field(StatusInfo, cardName),
	};
	sf_struct(t, StatusInfo, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "statusName");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<SpellInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(SpellInfo, originalCasterId),
		sf_field(SpellInfo, casterId),
		sf_field(SpellInfo, targetId),
		sf_field(SpellInfo, spellName),
		sf_field(SpellInfo, cardName),
		sf_field(SpellInfo, manualCast),
	};
	sf_struct(t, SpellInfo, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellName");
		info.prefab = true;
	}
	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<MeleeInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(MeleeInfo, attackerId),
		sf_field(MeleeInfo, targetId),
		sf_field(MeleeInfo, cardName),
	};
	sf_struct(t, MeleeInfo, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<DamageInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(DamageInfo, melee),
		sf_field(DamageInfo, physical),
		sf_field(DamageInfo, magic),
		sf_field(DamageInfo, passive),
		sf_field(DamageInfo, cardName),
		sf_field(DamageInfo, originalCasterId),
		sf_field(DamageInfo, causeId),
		sf_field(DamageInfo, targetId),
		sf_field(DamageInfo, damageRoll),
	};
	sf_struct(t, DamageInfo, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "cardName");
		info.prefab = true;
	}
}

template<> void initType<RollInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(RollInfo, name),
		sf_field(RollInfo, roll),
		sf_field(RollInfo, results),
		sf_field(RollInfo, total),
	};
	sf_struct(t, RollInfo, fields);
}

template<> void initType<CastInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(CastInfo, spellInfo),
		sf_field(CastInfo, rolls),
		sf_field(CastInfo, succeeded),
	};
	sf_struct(t, CastInfo, fields);

	{
		ReflectionInfo &info = addTypeReflectionInfo(t, "spellInfo");
		info.prefab = true;
	}
}

template<> void initType<Waypoint>(Type *t)
{
	static Field fields[] = {
		sf_field(Waypoint, position),
	};
	sf_struct(t, Waypoint, fields);
}

template<> void initType<TurnInfo>(Type *t)
{
	static Field fields[] = {
		sf_field(TurnInfo, startTurn),
		sf_field(TurnInfo, characterId),
		sf_field(TurnInfo, movementLeft),
	};
	sf_struct(t, TurnInfo, fields);
}

}

